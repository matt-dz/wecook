// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUsersTableExists = `-- name: CheckUsersTableExists :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      information_schema.tables
    WHERE
      table_schema = 'public'
      AND table_name = 'users')
`

func (q *Queries) CheckUsersTableExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, checkUsersTableExists)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAdmin = `-- name: CreateAdmin :one
INSERT INTO users (email, first_name, last_name, password_hash, role)
  VALUES (trim(lower($4::text)), $1, $2, $3, 'admin')
RETURNING
  id
`

type CreateAdminParams struct {
	FirstName    string
	LastName     string
	PasswordHash string
	Email        string
}

func (q *Queries) CreateAdmin(ctx context.Context, arg CreateAdminParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAdmin,
		arg.FirstName,
		arg.LastName,
		arg.PasswordHash,
		arg.Email,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (user_id, title)
  VALUES ($1, $2)
RETURNING
  id
`

type CreateRecipeParams struct {
	UserID pgtype.Int8
	Title  string
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (int64, error) {
	row := q.db.QueryRow(ctx, createRecipe, arg.UserID, arg.Title)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createRecipeIngredient = `-- name: CreateRecipeIngredient :one
INSERT INTO recipe_ingredients (recipe_id, quantity, unit, name, image_url)
  VALUES ($1, $2, $3, $4, $5)
RETURNING
  id
`

type CreateRecipeIngredientParams struct {
	RecipeID int64
	Quantity float32
	Unit     pgtype.Text
	Name     string
	ImageUrl pgtype.Text
}

func (q *Queries) CreateRecipeIngredient(ctx context.Context, arg CreateRecipeIngredientParams) (int64, error) {
	row := q.db.QueryRow(ctx, createRecipeIngredient,
		arg.RecipeID,
		arg.Quantity,
		arg.Unit,
		arg.Name,
		arg.ImageUrl,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, first_name, last_name, password_hash, role)
  VALUES (trim(lower($4::text)), $1, $2, $3, 'user')
RETURNING
  id
`

type CreateUserParams struct {
	FirstName    string
	LastName     string
	PasswordHash string
	Email        string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.PasswordHash,
		arg.Email,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAdminCount = `-- name: GetAdminCount :one
SELECT
  count(*)
FROM
  users
WHERE
  ROLE = 'admin'
`

func (q *Queries) GetAdminCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAdminCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRecipeOwner = `-- name: GetRecipeOwner :one
SELECT
  user_id
FROM
  recipes
WHERE
  id = $1
`

func (q *Queries) GetRecipeOwner(ctx context.Context, id int64) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, getRecipeOwner, id)
	var user_id pgtype.Int8
	err := row.Scan(&user_id)
	return user_id, err
}

const getUser = `-- name: GetUser :one
SELECT
  id,
  password_hash,
  ROLE
FROM
  users
WHERE
  email = trim(lower($1))
`

type GetUserRow struct {
	ID           int64
	PasswordHash string
	Role         Role
}

func (q *Queries) GetUser(ctx context.Context, lower string) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, lower)
	var i GetUserRow
	err := row.Scan(&i.ID, &i.PasswordHash, &i.Role)
	return i, err
}

const getUserRefreshTokenHash = `-- name: GetUserRefreshTokenHash :one
SELECT
  refresh_token_hash,
  refresh_token_expires_at
FROM
  users
WHERE
  id = $1
`

type GetUserRefreshTokenHashRow struct {
	RefreshTokenHash      pgtype.Text
	RefreshTokenExpiresAt pgtype.Timestamptz
}

func (q *Queries) GetUserRefreshTokenHash(ctx context.Context, id int64) (GetUserRefreshTokenHashRow, error) {
	row := q.db.QueryRow(ctx, getUserRefreshTokenHash, id)
	var i GetUserRefreshTokenHashRow
	err := row.Scan(&i.RefreshTokenHash, &i.RefreshTokenExpiresAt)
	return i, err
}

const getUserRole = `-- name: GetUserRole :one
SELECT
  ROLE
FROM
  users
WHERE
  id = $1
`

func (q *Queries) GetUserRole(ctx context.Context, id int64) (Role, error) {
	row := q.db.QueryRow(ctx, getUserRole, id)
	var role Role
	err := row.Scan(&role)
	return role, err
}

const updateRecipeIngredientImage = `-- name: UpdateRecipeIngredientImage :exec
UPDATE
  recipe_ingredients
SET
  image_url = $1
WHERE
  id = $2
`

type UpdateRecipeIngredientImageParams struct {
	ImageUrl pgtype.Text
	ID       int64
}

func (q *Queries) UpdateRecipeIngredientImage(ctx context.Context, arg UpdateRecipeIngredientImageParams) error {
	_, err := q.db.Exec(ctx, updateRecipeIngredientImage, arg.ImageUrl, arg.ID)
	return err
}

const updateUserRefreshTokenHash = `-- name: UpdateUserRefreshTokenHash :exec
UPDATE
  users
SET
  refresh_token_hash = $1
WHERE
  id = $2
`

type UpdateUserRefreshTokenHashParams struct {
	RefreshTokenHash pgtype.Text
	ID               int64
}

func (q *Queries) UpdateUserRefreshTokenHash(ctx context.Context, arg UpdateUserRefreshTokenHashParams) error {
	_, err := q.db.Exec(ctx, updateUserRefreshTokenHash, arg.RefreshTokenHash, arg.ID)
	return err
}

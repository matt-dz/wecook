// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkInsertRecipeIngredientsParams struct {
	RecipeID    int64
	Description pgtype.Text
	ImageUrl    pgtype.Text
}

type BulkInsertRecipeStepsParams struct {
	RecipeID    int64
	Instruction pgtype.Text
	ImageUrl    pgtype.Text
	StepNumber  int32
}

const checkIngredientOwnership = `-- name: CheckIngredientOwnership :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      recipe_ingredients ri
      JOIN recipes r ON r.id = ri.recipe_id
    WHERE
      r.id = $2::bigint
      AND ri.id = $3::bigint
      AND r.user_id = $1)
`

type CheckIngredientOwnershipParams struct {
	UserID       pgtype.Int8
	RecipeID     int64
	IngredientID int64
}

func (q *Queries) CheckIngredientOwnership(ctx context.Context, arg CheckIngredientOwnershipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkIngredientOwnership, arg.UserID, arg.RecipeID, arg.IngredientID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkRecipeOwnership = `-- name: CheckRecipeOwnership :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      recipes
    WHERE
      id = $1
      AND user_id = $2)
`

type CheckRecipeOwnershipParams struct {
	ID     int64
	UserID pgtype.Int8
}

func (q *Queries) CheckRecipeOwnership(ctx context.Context, arg CheckRecipeOwnershipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkRecipeOwnership, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkStepOwnership = `-- name: CheckStepOwnership :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      recipe_steps rs
      JOIN recipes r ON r.id = rs.recipe_id
    WHERE
      r.id = $2::bigint
      AND rs.id = $3::bigint
      AND r.user_id = $1)
`

type CheckStepOwnershipParams struct {
	UserID   pgtype.Int8
	RecipeID int64
	StepID   int64
}

func (q *Queries) CheckStepOwnership(ctx context.Context, arg CheckStepOwnershipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkStepOwnership, arg.UserID, arg.RecipeID, arg.StepID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUsersTableExists = `-- name: CheckUsersTableExists :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      information_schema.tables
    WHERE
      table_schema = 'public'
      AND table_name = 'users')
`

func (q *Queries) CheckUsersTableExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, checkUsersTableExists)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAdmin = `-- name: CreateAdmin :one
INSERT INTO users (email, first_name, last_name, password_hash, role)
  VALUES (trim(lower($4::text)), $1, $2, $3, 'admin')
RETURNING
  id
`

type CreateAdminParams struct {
	FirstName    string
	LastName     string
	PasswordHash string
	Email        string
}

func (q *Queries) CreateAdmin(ctx context.Context, arg CreateAdminParams) (int64, error) {
	row := q.db.QueryRow(ctx, createAdmin,
		arg.FirstName,
		arg.LastName,
		arg.PasswordHash,
		arg.Email,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createEmptyRecipeIngredient = `-- name: CreateEmptyRecipeIngredient :one
INSERT INTO recipe_ingredients (recipe_id)
  VALUES ($1)
RETURNING
  id, recipe_id, description, image_url, created_at, updated_at
`

func (q *Queries) CreateEmptyRecipeIngredient(ctx context.Context, recipeID int64) (RecipeIngredient, error) {
	row := q.db.QueryRow(ctx, createEmptyRecipeIngredient, recipeID)
	var i RecipeIngredient
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.Description,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createInviteCode = `-- name: CreateInviteCode :one
INSERT INTO invitation_codes (code_hash, invited_by)
  VALUES ($1, $2)
RETURNING
  id
`

type CreateInviteCodeParams struct {
	CodeHash  string
	InvitedBy pgtype.Int8
}

func (q *Queries) CreateInviteCode(ctx context.Context, arg CreateInviteCodeParams) (int64, error) {
	row := q.db.QueryRow(ctx, createInviteCode, arg.CodeHash, arg.InvitedBy)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createPreferences = `-- name: CreatePreferences :exec
INSERT INTO preferences (id)
  VALUES ($1)
ON CONFLICT (id)
  DO NOTHING
`

func (q *Queries) CreatePreferences(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, createPreferences, id)
	return err
}

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (user_id, title)
  VALUES ($1, $2)
RETURNING
  id
`

type CreateRecipeParams struct {
	UserID pgtype.Int8
	Title  string
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (int64, error) {
	row := q.db.QueryRow(ctx, createRecipe, arg.UserID, arg.Title)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createRecipeIngredient = `-- name: CreateRecipeIngredient :one
INSERT INTO recipe_ingredients (recipe_id, description, image_url)
  VALUES ($1, $2, $3)
RETURNING
  id
`

type CreateRecipeIngredientParams struct {
	RecipeID    int64
	Description pgtype.Text
	ImageUrl    pgtype.Text
}

func (q *Queries) CreateRecipeIngredient(ctx context.Context, arg CreateRecipeIngredientParams) (int64, error) {
	row := q.db.QueryRow(ctx, createRecipeIngredient, arg.RecipeID, arg.Description, arg.ImageUrl)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createRecipeStep = `-- name: CreateRecipeStep :one
INSERT INTO recipe_steps (recipe_id, instruction)
  VALUES ($1, $2)
RETURNING
  id, step_number
`

type CreateRecipeStepParams struct {
	RecipeID    int64
	Instruction pgtype.Text
}

type CreateRecipeStepRow struct {
	ID         int64
	StepNumber int32
}

func (q *Queries) CreateRecipeStep(ctx context.Context, arg CreateRecipeStepParams) (CreateRecipeStepRow, error) {
	row := q.db.QueryRow(ctx, createRecipeStep, arg.RecipeID, arg.Instruction)
	var i CreateRecipeStepRow
	err := row.Scan(&i.ID, &i.StepNumber)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, first_name, last_name, password_hash, role)
  VALUES (trim(lower($4::text)), $1, $2, $3, 'user')
RETURNING
  id
`

type CreateUserParams struct {
	FirstName    string
	LastName     string
	PasswordHash string
	Email        string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (int64, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.FirstName,
		arg.LastName,
		arg.PasswordHash,
		arg.Email,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteRecipe = `-- name: DeleteRecipe :exec
DELETE FROM recipes
WHERE id = $1
`

func (q *Queries) DeleteRecipe(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRecipe, id)
	return err
}

const deleteRecipeIngredient = `-- name: DeleteRecipeIngredient :exec
DELETE FROM recipe_ingredients
WHERE id = $1
`

func (q *Queries) DeleteRecipeIngredient(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRecipeIngredient, id)
	return err
}

const deleteRecipeIngredientImageURL = `-- name: DeleteRecipeIngredientImageURL :exec
UPDATE
  recipe_ingredients
SET
  image_url = NULL
WHERE
  id = $1
`

func (q *Queries) DeleteRecipeIngredientImageURL(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRecipeIngredientImageURL, id)
	return err
}

const deleteRecipeIngredientsByIDs = `-- name: DeleteRecipeIngredientsByIDs :exec
DELETE FROM recipe_ingredients
WHERE recipe_id = $1
  AND id = ANY ($2::bigint[])
`

type DeleteRecipeIngredientsByIDsParams struct {
	RecipeID int64
	Ids      []int64
}

func (q *Queries) DeleteRecipeIngredientsByIDs(ctx context.Context, arg DeleteRecipeIngredientsByIDsParams) error {
	_, err := q.db.Exec(ctx, deleteRecipeIngredientsByIDs, arg.RecipeID, arg.Ids)
	return err
}

const deleteRecipeStep = `-- name: DeleteRecipeStep :exec
DELETE FROM recipe_steps
WHERE id = $1
`

func (q *Queries) DeleteRecipeStep(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRecipeStep, id)
	return err
}

const deleteRecipeStepImageURL = `-- name: DeleteRecipeStepImageURL :exec
UPDATE
  recipe_steps
SET
  image_url = NULL
WHERE
  id = $1
`

func (q *Queries) DeleteRecipeStepImageURL(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteRecipeStepImageURL, id)
	return err
}

const deleteRecipeStepsByIDs = `-- name: DeleteRecipeStepsByIDs :exec
DELETE FROM recipe_steps
WHERE recipe_id = $1
  AND id = ANY ($2::bigint[])
`

type DeleteRecipeStepsByIDsParams struct {
	RecipeID int64
	Ids      []int64
}

func (q *Queries) DeleteRecipeStepsByIDs(ctx context.Context, arg DeleteRecipeStepsByIDsParams) error {
	_, err := q.db.Exec(ctx, deleteRecipeStepsByIDs, arg.RecipeID, arg.Ids)
	return err
}

const deleteUser = `-- name: DeleteUser :execrows
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, deleteUser, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getAdminCount = `-- name: GetAdminCount :one
SELECT
  count(*)
FROM
  users
WHERE
  ROLE = 'admin'
`

func (q *Queries) GetAdminCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getAdminCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllowPublicSignupPreference = `-- name: GetAllowPublicSignupPreference :one
SELECT
  allow_public_signup
FROM
  preferences
WHERE
  id = $1
`

func (q *Queries) GetAllowPublicSignupPreference(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, getAllowPublicSignupPreference, id)
	var allow_public_signup bool
	err := row.Scan(&allow_public_signup)
	return allow_public_signup, err
}

const getInvitationCode = `-- name: GetInvitationCode :one
SELECT
  code_hash
FROM
  valid_invitation_codes
WHERE
  id = $1
`

func (q *Queries) GetInvitationCode(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRow(ctx, getInvitationCode, id)
	var code_hash string
	err := row.Scan(&code_hash)
	return code_hash, err
}

const getPreferences = `-- name: GetPreferences :one
SELECT
  id,
  allow_public_signup
FROM
  preferences
WHERE
  id = $1
`

func (q *Queries) GetPreferences(ctx context.Context, id int32) (Preference, error) {
	row := q.db.QueryRow(ctx, getPreferences, id)
	var i Preference
	err := row.Scan(&i.ID, &i.AllowPublicSignup)
	return i, err
}

const getPublicRecipes = `-- name: GetPublicRecipes :many
SELECT
  r.user_id,
  r.image_url,
  r.title,
  r.description,
  r.created_at,
  r.updated_at,
  r.published,
  r.cook_time_amount,
  r.cook_time_unit,
  r.prep_time_amount,
  r.prep_time_unit,
  r.id AS recipe_id,
  r.servings,
  u.first_name,
  u.last_name
FROM
  recipes r
  JOIN users u ON r.user_id = u.id
WHERE
  r.published = TRUE
ORDER BY
  r.updated_at DESC
`

type GetPublicRecipesRow struct {
	UserID         pgtype.Int8
	ImageUrl       pgtype.Text
	Title          string
	Description    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Published      bool
	CookTimeAmount pgtype.Int4
	CookTimeUnit   NullTimeUnit
	PrepTimeAmount pgtype.Int4
	PrepTimeUnit   NullTimeUnit
	RecipeID       int64
	Servings       pgtype.Float4
	FirstName      string
	LastName       string
}

func (q *Queries) GetPublicRecipes(ctx context.Context) ([]GetPublicRecipesRow, error) {
	rows, err := q.db.Query(ctx, getPublicRecipes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPublicRecipesRow
	for rows.Next() {
		var i GetPublicRecipesRow
		if err := rows.Scan(
			&i.UserID,
			&i.ImageUrl,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Published,
			&i.CookTimeAmount,
			&i.CookTimeUnit,
			&i.PrepTimeAmount,
			&i.PrepTimeUnit,
			&i.RecipeID,
			&i.Servings,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPublishedRecipeAndOwner = `-- name: GetPublishedRecipeAndOwner :one
SELECT
  r.user_id,
  r.image_url,
  r.title,
  r.description,
  r.created_at,
  r.updated_at,
  r.published,
  r.id,
  r.servings,
  r.cook_time_amount,
  r.cook_time_unit,
  r.prep_time_amount,
  r.prep_time_unit,
  u.first_name,
  u.last_name,
  u.id
FROM
  recipes r
  JOIN users u ON r.user_id = u.id
WHERE
  r.id = $1
  AND published = TRUE
`

type GetPublishedRecipeAndOwnerRow struct {
	UserID         pgtype.Int8
	ImageUrl       pgtype.Text
	Title          string
	Description    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Published      bool
	ID             int64
	Servings       pgtype.Float4
	CookTimeAmount pgtype.Int4
	CookTimeUnit   NullTimeUnit
	PrepTimeAmount pgtype.Int4
	PrepTimeUnit   NullTimeUnit
	FirstName      string
	LastName       string
	ID_2           int64
}

func (q *Queries) GetPublishedRecipeAndOwner(ctx context.Context, id int64) (GetPublishedRecipeAndOwnerRow, error) {
	row := q.db.QueryRow(ctx, getPublishedRecipeAndOwner, id)
	var i GetPublishedRecipeAndOwnerRow
	err := row.Scan(
		&i.UserID,
		&i.ImageUrl,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Published,
		&i.ID,
		&i.Servings,
		&i.CookTimeAmount,
		&i.CookTimeUnit,
		&i.PrepTimeAmount,
		&i.PrepTimeUnit,
		&i.FirstName,
		&i.LastName,
		&i.ID_2,
	)
	return i, err
}

const getRecipeAndOwner = `-- name: GetRecipeAndOwner :one
SELECT
  r.user_id,
  r.image_url,
  r.title,
  r.description,
  r.created_at,
  r.updated_at,
  r.published,
  r.id,
  r.cook_time_amount,
  r.cook_time_unit,
  r.prep_time_amount,
  r.prep_time_unit,
  r.servings,
  u.first_name,
  u.last_name,
  u.id
FROM
  recipes r
  JOIN users u ON r.user_id = u.id
WHERE
  r.id = $1
`

type GetRecipeAndOwnerRow struct {
	UserID         pgtype.Int8
	ImageUrl       pgtype.Text
	Title          string
	Description    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Published      bool
	ID             int64
	CookTimeAmount pgtype.Int4
	CookTimeUnit   NullTimeUnit
	PrepTimeAmount pgtype.Int4
	PrepTimeUnit   NullTimeUnit
	Servings       pgtype.Float4
	FirstName      string
	LastName       string
	ID_2           int64
}

func (q *Queries) GetRecipeAndOwner(ctx context.Context, id int64) (GetRecipeAndOwnerRow, error) {
	row := q.db.QueryRow(ctx, getRecipeAndOwner, id)
	var i GetRecipeAndOwnerRow
	err := row.Scan(
		&i.UserID,
		&i.ImageUrl,
		&i.Title,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Published,
		&i.ID,
		&i.CookTimeAmount,
		&i.CookTimeUnit,
		&i.PrepTimeAmount,
		&i.PrepTimeUnit,
		&i.Servings,
		&i.FirstName,
		&i.LastName,
		&i.ID_2,
	)
	return i, err
}

const getRecipeImageURL = `-- name: GetRecipeImageURL :one
SELECT
  image_url
FROM
  recipes
WHERE
  id = $1
`

func (q *Queries) GetRecipeImageURL(ctx context.Context, id int64) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getRecipeImageURL, id)
	var image_url pgtype.Text
	err := row.Scan(&image_url)
	return image_url, err
}

const getRecipeIngredientExistence = `-- name: GetRecipeIngredientExistence :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      recipe_ingredients
    WHERE
      id = $1)
`

func (q *Queries) GetRecipeIngredientExistence(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, getRecipeIngredientExistence, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getRecipeIngredientIDs = `-- name: GetRecipeIngredientIDs :many
SELECT
  id
FROM
  recipe_ingredients
WHERE
  recipe_id = $1
`

func (q *Queries) GetRecipeIngredientIDs(ctx context.Context, recipeID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getRecipeIngredientIDs, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeIngredientImageURL = `-- name: GetRecipeIngredientImageURL :one
SELECT
  image_url
FROM
  recipe_ingredients
WHERE
  id = $1
`

func (q *Queries) GetRecipeIngredientImageURL(ctx context.Context, id int64) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getRecipeIngredientImageURL, id)
	var image_url pgtype.Text
	err := row.Scan(&image_url)
	return image_url, err
}

const getRecipeIngredients = `-- name: GetRecipeIngredients :many
SELECT
  id,
  recipe_id,
  description,
  image_url,
  created_at,
  updated_at
FROM
  recipe_ingredients
WHERE
  recipe_id = $1
ORDER BY
  created_at ASC
`

func (q *Queries) GetRecipeIngredients(ctx context.Context, recipeID int64) ([]RecipeIngredient, error) {
	rows, err := q.db.Query(ctx, getRecipeIngredients, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeIngredient
	for rows.Next() {
		var i RecipeIngredient
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.Description,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeOwner = `-- name: GetRecipeOwner :one
SELECT
  user_id
FROM
  recipes
WHERE
  id = $1
`

func (q *Queries) GetRecipeOwner(ctx context.Context, id int64) (pgtype.Int8, error) {
	row := q.db.QueryRow(ctx, getRecipeOwner, id)
	var user_id pgtype.Int8
	err := row.Scan(&user_id)
	return user_id, err
}

const getRecipeStepExistence = `-- name: GetRecipeStepExistence :one
SELECT
  EXISTS (
    SELECT
      1
    FROM
      recipe_steps
    WHERE
      id = $1)
`

func (q *Queries) GetRecipeStepExistence(ctx context.Context, id int64) (bool, error) {
	row := q.db.QueryRow(ctx, getRecipeStepExistence, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getRecipeStepIDs = `-- name: GetRecipeStepIDs :many
SELECT
  id
FROM
  recipe_steps
WHERE
  recipe_id = $1
`

func (q *Queries) GetRecipeStepIDs(ctx context.Context, recipeID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, getRecipeStepIDs, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipeStepImageURL = `-- name: GetRecipeStepImageURL :one
SELECT
  image_url
FROM
  recipe_steps
WHERE
  id = $1
`

func (q *Queries) GetRecipeStepImageURL(ctx context.Context, id int64) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getRecipeStepImageURL, id)
	var image_url pgtype.Text
	err := row.Scan(&image_url)
	return image_url, err
}

const getRecipeSteps = `-- name: GetRecipeSteps :many
SELECT
  id, recipe_id, step_number, instruction, image_url, created_at, updated_at
FROM
  recipe_steps
WHERE
  recipe_id = $1
ORDER BY
  step_number ASC
`

func (q *Queries) GetRecipeSteps(ctx context.Context, recipeID int64) ([]RecipeStep, error) {
	rows, err := q.db.Query(ctx, getRecipeSteps, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipeStep
	for rows.Next() {
		var i RecipeStep
		if err := rows.Scan(
			&i.ID,
			&i.RecipeID,
			&i.StepNumber,
			&i.Instruction,
			&i.ImageUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipesByOwner = `-- name: GetRecipesByOwner :many
SELECT
  r.user_id,
  r.image_url,
  r.title,
  r.description,
  r.created_at,
  r.updated_at,
  r.published,
  r.cook_time_amount,
  r.cook_time_unit,
  r.prep_time_amount,
  r.prep_time_unit,
  r.id AS recipe_id,
  r.servings,
  u.first_name,
  u.last_name
FROM
  recipes r
  JOIN users u ON r.user_id = u.id
WHERE
  u.id = $1
ORDER BY
  r.updated_at DESC
`

type GetRecipesByOwnerRow struct {
	UserID         pgtype.Int8
	ImageUrl       pgtype.Text
	Title          string
	Description    pgtype.Text
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	Published      bool
	CookTimeAmount pgtype.Int4
	CookTimeUnit   NullTimeUnit
	PrepTimeAmount pgtype.Int4
	PrepTimeUnit   NullTimeUnit
	RecipeID       int64
	Servings       pgtype.Float4
	FirstName      string
	LastName       string
}

func (q *Queries) GetRecipesByOwner(ctx context.Context, id int64) ([]GetRecipesByOwnerRow, error) {
	rows, err := q.db.Query(ctx, getRecipesByOwner, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecipesByOwnerRow
	for rows.Next() {
		var i GetRecipesByOwnerRow
		if err := rows.Scan(
			&i.UserID,
			&i.ImageUrl,
			&i.Title,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Published,
			&i.CookTimeAmount,
			&i.CookTimeUnit,
			&i.PrepTimeAmount,
			&i.PrepTimeUnit,
			&i.RecipeID,
			&i.Servings,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT
  id,
  password_hash,
  ROLE
FROM
  users
WHERE
  email = trim(lower($1))
`

type GetUserRow struct {
	ID           int64
	PasswordHash string
	Role         Role
}

func (q *Queries) GetUser(ctx context.Context, lower string) (GetUserRow, error) {
	row := q.db.QueryRow(ctx, getUser, lower)
	var i GetUserRow
	err := row.Scan(&i.ID, &i.PasswordHash, &i.Role)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT
  id,
  email,
  first_name,
  last_name,
  ROLE
FROM
  users
WHERE
  id = $1
`

type GetUserByIdRow struct {
	ID        int64
	Email     string
	FirstName string
	LastName  string
	Role      Role
}

func (q *Queries) GetUserById(ctx context.Context, id int64) (GetUserByIdRow, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i GetUserByIdRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Role,
	)
	return i, err
}

const getUserPasswordHash = `-- name: GetUserPasswordHash :one
SELECT
  password_hash
FROM
  users
WHERE
  id = $1
`

func (q *Queries) GetUserPasswordHash(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRow(ctx, getUserPasswordHash, id)
	var password_hash string
	err := row.Scan(&password_hash)
	return password_hash, err
}

const getUserRecipeImages = `-- name: GetUserRecipeImages :many
SELECT
  image_url
FROM
  recipes
WHERE
  user_id = $1
  AND image_url IS NOT NULL
`

func (q *Queries) GetUserRecipeImages(ctx context.Context, userID pgtype.Int8) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, getUserRecipeImages, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var image_url pgtype.Text
		if err := rows.Scan(&image_url); err != nil {
			return nil, err
		}
		items = append(items, image_url)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRecipeIngredientImages = `-- name: GetUserRecipeIngredientImages :many
SELECT
  ri.image_url
FROM
  recipes r
  JOIN recipe_ingredients ri ON r.id = ri.recipe_id
WHERE
  r.user_id = $1
  AND ri.image_url IS NOT NULL
`

func (q *Queries) GetUserRecipeIngredientImages(ctx context.Context, userID pgtype.Int8) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, getUserRecipeIngredientImages, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var image_url pgtype.Text
		if err := rows.Scan(&image_url); err != nil {
			return nil, err
		}
		items = append(items, image_url)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRecipeStepImages = `-- name: GetUserRecipeStepImages :many
SELECT
  rs.image_url
FROM
  recipes r
  JOIN recipe_steps rs ON r.id = rs.recipe_id
WHERE
  r.user_id = $1
  AND rs.image_url IS NOT NULL
`

func (q *Queries) GetUserRecipeStepImages(ctx context.Context, userID pgtype.Int8) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, getUserRecipeStepImages, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var image_url pgtype.Text
		if err := rows.Scan(&image_url); err != nil {
			return nil, err
		}
		items = append(items, image_url)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRefreshTokenHash = `-- name: GetUserRefreshTokenHash :one
SELECT
  refresh_token_hash,
  refresh_token_expires_at
FROM
  users
WHERE
  id = $1
`

type GetUserRefreshTokenHashRow struct {
	RefreshTokenHash      pgtype.Text
	RefreshTokenExpiresAt pgtype.Timestamptz
}

func (q *Queries) GetUserRefreshTokenHash(ctx context.Context, id int64) (GetUserRefreshTokenHashRow, error) {
	row := q.db.QueryRow(ctx, getUserRefreshTokenHash, id)
	var i GetUserRefreshTokenHashRow
	err := row.Scan(&i.RefreshTokenHash, &i.RefreshTokenExpiresAt)
	return i, err
}

const getUserRole = `-- name: GetUserRole :one
SELECT
  ROLE
FROM
  users
WHERE
  id = $1
`

func (q *Queries) GetUserRole(ctx context.Context, id int64) (Role, error) {
	row := q.db.QueryRow(ctx, getUserRole, id)
	var role Role
	err := row.Scan(&role)
	return role, err
}

const getUsers = `-- name: GetUsers :many
SELECT
  id,
  email,
  first_name,
  last_name,
  ROLE
FROM
  users
WHERE
  id > coalesce($1, 0)
ORDER BY
  id
LIMIT LEAST (100, GREATEST (1, coalesce($2::int, 20)))
`

type GetUsersParams struct {
	After pgtype.Int8
	Limit pgtype.Int4
}

type GetUsersRow struct {
	ID        int64
	Email     string
	FirstName string
	LastName  string
	Role      Role
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]GetUsersRow, error) {
	rows, err := q.db.Query(ctx, getUsers, arg.After, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersRow
	for rows.Next() {
		var i GetUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const redeemInvitationCode = `-- name: RedeemInvitationCode :execrows
UPDATE
  valid_invitation_codes
SET
  used_at = now()
WHERE
  id = $1
`

func (q *Queries) RedeemInvitationCode(ctx context.Context, id int64) (int64, error) {
	result, err := q.db.Exec(ctx, redeemInvitationCode, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updatePreferences = `-- name: UpdatePreferences :one
UPDATE
  preferences
SET
  allow_public_signup = CASE WHEN $2::boolean THEN
    $3
  ELSE
    allow_public_signup
  END
WHERE
  id = $1
RETURNING
  id,
  allow_public_signup
`

type UpdatePreferencesParams struct {
	ID                      int32
	UpdateAllowPublicSignup pgtype.Bool
	AllowPublicSignup       pgtype.Bool
}

func (q *Queries) UpdatePreferences(ctx context.Context, arg UpdatePreferencesParams) (Preference, error) {
	row := q.db.QueryRow(ctx, updatePreferences, arg.ID, arg.UpdateAllowPublicSignup, arg.AllowPublicSignup)
	var i Preference
	err := row.Scan(&i.ID, &i.AllowPublicSignup)
	return i, err
}

const updateRecipe = `-- name: UpdateRecipe :one
UPDATE
  recipes
SET
  image_url = CASE WHEN $2::boolean THEN
    $3
  ELSE
    image_url
  END,
  title = CASE WHEN $4::boolean THEN
    $5
  ELSE
    title
  END,
  description = CASE WHEN $6::boolean THEN
    $7
  ELSE
    description
  END,
  published = CASE WHEN $8::boolean THEN
    $9
  ELSE
    published
  END,
  cook_time_amount = CASE WHEN $10::boolean THEN
    $11
  ELSE
    cook_time_amount
  END,
  cook_time_unit = CASE WHEN $12::boolean THEN
    $13
  ELSE
    cook_time_unit
  END,
  prep_time_amount = CASE WHEN $14::boolean THEN
    $15
  ELSE
    prep_time_amount
  END,
  prep_time_unit = CASE WHEN $16::boolean THEN
    $17
  ELSE
    prep_time_unit
  END,
  servings = CASE WHEN $18::boolean THEN
    $19
  ELSE
    servings
  END
WHERE
  id = $1
RETURNING
  id,
  image_url,
  title,
  description,
  published,
  cook_time_amount,
  cook_time_unit,
  prep_time_amount,
  prep_time_unit,
  servings,
  updated_at,
  created_at
`

type UpdateRecipeParams struct {
	ID                   int64
	UpdateImageUrl       pgtype.Bool
	ImageUrl             pgtype.Text
	UpdateTitle          pgtype.Bool
	Title                pgtype.Text
	UpdateDescription    pgtype.Bool
	Description          pgtype.Text
	UpdatePublished      pgtype.Bool
	Published            pgtype.Bool
	UpdateCookTimeAmount pgtype.Bool
	CookTimeAmount       pgtype.Int4
	UpdateCookTimeUnit   pgtype.Bool
	CookTimeUnit         NullTimeUnit
	UpdatePrepTimeAmount pgtype.Bool
	PrepTimeAmount       pgtype.Int4
	UpdatePrepTimeUnit   pgtype.Bool
	PrepTimeUnit         NullTimeUnit
	UpdateServings       pgtype.Bool
	Servings             pgtype.Float4
}

type UpdateRecipeRow struct {
	ID             int64
	ImageUrl       pgtype.Text
	Title          string
	Description    pgtype.Text
	Published      bool
	CookTimeAmount pgtype.Int4
	CookTimeUnit   NullTimeUnit
	PrepTimeAmount pgtype.Int4
	PrepTimeUnit   NullTimeUnit
	Servings       pgtype.Float4
	UpdatedAt      pgtype.Timestamptz
	CreatedAt      pgtype.Timestamptz
}

func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) (UpdateRecipeRow, error) {
	row := q.db.QueryRow(ctx, updateRecipe,
		arg.ID,
		arg.UpdateImageUrl,
		arg.ImageUrl,
		arg.UpdateTitle,
		arg.Title,
		arg.UpdateDescription,
		arg.Description,
		arg.UpdatePublished,
		arg.Published,
		arg.UpdateCookTimeAmount,
		arg.CookTimeAmount,
		arg.UpdateCookTimeUnit,
		arg.CookTimeUnit,
		arg.UpdatePrepTimeAmount,
		arg.PrepTimeAmount,
		arg.UpdatePrepTimeUnit,
		arg.PrepTimeUnit,
		arg.UpdateServings,
		arg.Servings,
	)
	var i UpdateRecipeRow
	err := row.Scan(
		&i.ID,
		&i.ImageUrl,
		&i.Title,
		&i.Description,
		&i.Published,
		&i.CookTimeAmount,
		&i.CookTimeUnit,
		&i.PrepTimeAmount,
		&i.PrepTimeUnit,
		&i.Servings,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const updateRecipeCoverImage = `-- name: UpdateRecipeCoverImage :exec
UPDATE
  recipes
SET
  image_url = $1
WHERE
  id = $2
`

type UpdateRecipeCoverImageParams struct {
	ImageUrl pgtype.Text
	ID       int64
}

func (q *Queries) UpdateRecipeCoverImage(ctx context.Context, arg UpdateRecipeCoverImageParams) error {
	_, err := q.db.Exec(ctx, updateRecipeCoverImage, arg.ImageUrl, arg.ID)
	return err
}

const updateRecipeIngredient = `-- name: UpdateRecipeIngredient :one
UPDATE
  recipe_ingredients
SET
  description = CASE WHEN $2::boolean THEN
    $3
  ELSE
    description
  END,
  image_url = CASE WHEN $4::boolean THEN
    $5
  ELSE
    image_url
  END
WHERE
  id = $1
RETURNING
  id,
  recipe_id,
  description,
  image_url,
  created_at,
  updated_at
`

type UpdateRecipeIngredientParams struct {
	ID                int64
	UpdateDescription pgtype.Bool
	Description       pgtype.Text
	UpdateImageUrl    pgtype.Bool
	ImageUrl          pgtype.Text
}

func (q *Queries) UpdateRecipeIngredient(ctx context.Context, arg UpdateRecipeIngredientParams) (RecipeIngredient, error) {
	row := q.db.QueryRow(ctx, updateRecipeIngredient,
		arg.ID,
		arg.UpdateDescription,
		arg.Description,
		arg.UpdateImageUrl,
		arg.ImageUrl,
	)
	var i RecipeIngredient
	err := row.Scan(
		&i.ID,
		&i.RecipeID,
		&i.Description,
		&i.ImageUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRecipeIngredientImage = `-- name: UpdateRecipeIngredientImage :exec
UPDATE
  recipe_ingredients
SET
  image_url = $1
WHERE
  id = $2
`

type UpdateRecipeIngredientImageParams struct {
	ImageUrl pgtype.Text
	ID       int64
}

func (q *Queries) UpdateRecipeIngredientImage(ctx context.Context, arg UpdateRecipeIngredientImageParams) error {
	_, err := q.db.Exec(ctx, updateRecipeIngredientImage, arg.ImageUrl, arg.ID)
	return err
}

const updateRecipeStep = `-- name: UpdateRecipeStep :one
UPDATE
  recipe_steps
SET
  instruction = CASE WHEN $2::boolean THEN
    $3
  ELSE
    instruction
  END,
  step_number = CASE WHEN $4::boolean THEN
    $5
  ELSE
    step_number
  END,
  image_url = CASE WHEN $6::boolean THEN
    $7
  ELSE
    image_url
  END
WHERE
  id = $1
RETURNING
  id,
  instruction,
  step_number,
  image_url
`

type UpdateRecipeStepParams struct {
	ID                int64
	UpdateInstruction pgtype.Bool
	Instruction       pgtype.Text
	UpdateStepNumber  pgtype.Bool
	StepNumber        pgtype.Int4
	UpdateImageUrl    pgtype.Bool
	ImageUrl          pgtype.Text
}

type UpdateRecipeStepRow struct {
	ID          int64
	Instruction pgtype.Text
	StepNumber  int32
	ImageUrl    pgtype.Text
}

func (q *Queries) UpdateRecipeStep(ctx context.Context, arg UpdateRecipeStepParams) (UpdateRecipeStepRow, error) {
	row := q.db.QueryRow(ctx, updateRecipeStep,
		arg.ID,
		arg.UpdateInstruction,
		arg.Instruction,
		arg.UpdateStepNumber,
		arg.StepNumber,
		arg.UpdateImageUrl,
		arg.ImageUrl,
	)
	var i UpdateRecipeStepRow
	err := row.Scan(
		&i.ID,
		&i.Instruction,
		&i.StepNumber,
		&i.ImageUrl,
	)
	return i, err
}

const updateRecipeStepImage = `-- name: UpdateRecipeStepImage :exec
UPDATE
  recipe_steps
SET
  image_url = $1
WHERE
  id = $2
`

type UpdateRecipeStepImageParams struct {
	ImageUrl pgtype.Text
	ID       int64
}

func (q *Queries) UpdateRecipeStepImage(ctx context.Context, arg UpdateRecipeStepImageParams) error {
	_, err := q.db.Exec(ctx, updateRecipeStepImage, arg.ImageUrl, arg.ID)
	return err
}

const updateUserPasswordHash = `-- name: UpdateUserPasswordHash :exec
UPDATE
  users
SET
  password_hash = $1
WHERE
  id = $2
`

type UpdateUserPasswordHashParams struct {
	PasswordHash string
	ID           int64
}

func (q *Queries) UpdateUserPasswordHash(ctx context.Context, arg UpdateUserPasswordHashParams) error {
	_, err := q.db.Exec(ctx, updateUserPasswordHash, arg.PasswordHash, arg.ID)
	return err
}

const updateUserRefreshTokenHash = `-- name: UpdateUserRefreshTokenHash :exec
UPDATE
  users
SET
  refresh_token_hash = $1
WHERE
  id = $2
`

type UpdateUserRefreshTokenHashParams struct {
	RefreshTokenHash pgtype.Text
	ID               int64
}

func (q *Queries) UpdateUserRefreshTokenHash(ctx context.Context, arg UpdateUserRefreshTokenHashParams) error {
	_, err := q.db.Exec(ctx, updateUserRefreshTokenHash, arg.RefreshTokenHash, arg.ID)
	return err
}
